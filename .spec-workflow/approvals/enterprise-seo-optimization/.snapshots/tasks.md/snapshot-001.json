{
  "id": "snapshot_1759341714522_61wlp7yav",
  "approvalId": "approval_1759341714520_g8lu1gx2q",
  "approvalTitle": "Tasks: Enterprise-SEO-Optimierung (35 Tasks)",
  "version": 1,
  "timestamp": "2025-10-01T18:01:54.522Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Tasks Document\n\n## Phase 1: Foundation & Type System\n\n- [ ] 1. Create content type definitions\n  - Files: `lib/types/content.ts`, `lib/types/schema.ts`\n  - Define TypeScript interfaces for BlogPost, PortfolioProject, ServicePage, CityPage\n  - Create Schema.org types for ArticleSchema, FAQSchema, CreativeWorkSchema, etc.\n  - Purpose: Establish type safety for entire content system\n  - _Leverage: Existing types from lib/types.ts, tech.md TypeScript patterns (Zeile 8-13)_\n  - _Requirements: Req 1, Req 2, Req 5_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: TypeScript Developer specializing in type systems | Task: Create comprehensive TypeScript interfaces for content types (BlogPost, PortfolioProject, ServicePage, CityPage) and Schema.org types (ArticleSchema, FAQSchema, CreativeWorkSchema, PersonSchema, ReviewSchema, BreadcrumbSchema) following design.md lines 280-370. All types must match the exact data models from design document. | Restrictions: Use TypeScript strict mode, no `any` types, all optional fields marked with `?`, date fields as ISO 8601 strings, follow naming conventions from structure.md lines 142-146 | _Leverage: lib/types.ts existing patterns, lib/validations.ts Zod pattern | _Requirements: Req 1 (Blog types), Req 2 (Portfolio types), Req 5 (Schema types) | Success: All content types compile without errors, Schema types match Schema.org spec, types support all frontmatter fields from requirements. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n- [ ] 2. Create Zod validation schemas for frontmatter\n  - File: `lib/content/frontmatter.ts`\n  - Implement Zod schemas for BlogPost, PortfolioProject, ServicePage, CityPage frontmatter\n  - Add runtime validation with clear error messages\n  - Purpose: Validate MDX frontmatter at build time (fail fast on invalid content)\n  - _Leverage: lib/validations.ts existing Zod patterns, lib/types/content.ts from Task 1_\n  - _Requirements: Req 1, Req 2, Req 3, Req 4, Req 7_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: Backend Developer with Zod validation expertise | Task: Create Zod validation schemas for all content frontmatter types matching interfaces from Task 1. Each schema must validate required fields, date formats (ISO 8601), array structures, nested objects (author, client, metrics, etc.), and provide descriptive error messages. Export schemas as `blogPostFrontmatterSchema`, `portfolioProjectFrontmatterSchema`, `servicePageFrontmatterSchema`, `cityPageFrontmatterSchema`. | Restrictions: All required fields from design.md data models must be enforced, optional fields use `.optional()`, dates validated as ISO strings, no loose validation | _Leverage: lib/validations.ts Zod patterns (lines 4-50), z.object() patterns | _Requirements: Req 1 (blog validation), Req 2 (portfolio validation), Req 3 (service validation), Req 4 (city validation), Req 7 (content quality) | Success: All schemas compile, invalid frontmatter throws clear Zod errors at build time, schemas match TypeScript types exactly. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n## Phase 2: Content Infrastructure\n\n- [ ] 3. Create MDX loader utility\n  - File: `lib/content/mdx-loader.ts`\n  - Implement `loadMDX(slug, contentType)` function to read and parse MDX files\n  - Add frontmatter extraction and Zod validation\n  - Purpose: Core utility for loading all MDX content\n  - _Leverage: Node.js fs/promises, gray-matter for frontmatter, Task 2 Zod schemas_\n  - _Requirements: Req 1, Req 7_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: Node.js Developer with file system expertise | Task: Create MDX loader utility that reads MDX files from `content/{contentType}/{slug}.mdx`, extracts frontmatter using gray-matter, validates with Zod schemas from Task 2, and returns { slug, frontmatter, content }. Function signature: `async function loadMDX(slug: string, contentType: 'blog' | 'portfolio' | 'services' | 'cities'): Promise<ContentResult | null>`. Return null if file not found (don't throw). | Restrictions: Use Node.js fs.promises (not sync), handle ENOENT gracefully, validate frontmatter before returning, sanitize file paths to prevent directory traversal, only read from content/ directory | _Leverage: Node.js fs/promises API, gray-matter package, lib/content/frontmatter.ts schemas | _Requirements: Req 1 (blog loading), Req 7 (content infrastructure) | Success: Function loads MDX files correctly, validates frontmatter, returns null for missing files, prevents directory traversal. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n- [ ] 4. Create content API module\n  - File: `lib/content/content-api.ts`\n  - Implement high-level functions: `getAllBlogPosts()`, `getBlogPost(slug)`, `getAllPortfolioProjects()`, etc.\n  - Add sorting, filtering, and pagination helpers\n  - Purpose: Abstraction layer over mdx-loader for easy content access\n  - _Leverage: lib/content/mdx-loader.ts from Task 3_\n  - _Requirements: Req 1, Req 2, Req 3, Req 4, Req 7_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: API Developer with data abstraction expertise | Task: Create content API module with functions for each content type. Implement: `getAllBlogPosts(options?)`, `getBlogPost(slug)`, `getRelatedBlogPosts(slug, maxResults)`, `getAllPortfolioProjects()`, `getPortfolioProject(slug)`, `getAllServicePages()`, `getServicePage(slug)`, `getAllCityPages()`, `getCityPage(slug)`. Add options for sorting (by date, featured), filtering (by tag, category), pagination. Functions should use loadMDX from Task 3 and handle errors gracefully. | Restrictions: Cache results in memory during build for performance, sort blog posts by publishedAt desc by default, filter out draft posts in production, return empty arrays (not null) for \"get all\" functions | _Leverage: lib/content/mdx-loader.ts loadMDX function, Array.sort() and .filter() | _Requirements: Req 1 (blog API), Req 2 (portfolio API), Req 3 (service API), Req 4 (city API), Req 7 (performance) | Success: All API functions work correctly, sorting and filtering work, empty arrays for missing content, related posts algorithm works. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n- [ ] 5. Set up MDX compilation with next-mdx-remote\n  - Files: `lib/content/mdx-compiler.ts`, `package.json`\n  - Install next-mdx-remote, rehype-pretty-code, rehype-slug, rehype-autolink-headings\n  - Create `compileMDXContent(content)` function with plugins\n  - Purpose: Compile MDX to React with syntax highlighting and auto-linking\n  - _Leverage: next-mdx-remote/rsc, rehype ecosystem_\n  - _Requirements: Req 1, Req 7_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: Frontend Developer with MDX expertise | Task: Install dependencies: `pnpm add next-mdx-remote rehype-pretty-code rehype-slug rehype-autolink-headings shiki`. Create mdx-compiler.ts with async function `compileMDXContent(content: string)` that uses compileMDX from next-mdx-remote/rsc with options: { parseFrontmatter: false, mdxOptions: { rehypePlugins: [rehypePrettyCode (Shiki theme: github-dark), rehypeSlug, rehypeAutolinkHeadings] } }. Return compiled result with components. | Restrictions: Use next-mdx-remote/rsc (server components), configure Shiki with github-dark theme, add IDs to all headings via rehypeSlug, auto-link headings, don't parse frontmatter here (already done in loader) | _Leverage: next-mdx-remote/rsc documentation, rehype plugin ecosystem, Shiki themes | _Requirements: Req 1 (blog rendering), Req 7 (syntax highlighting, reading experience) | Success: MDX compiles to React, code blocks have syntax highlighting, headings have IDs and auto-links, no hydration errors. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n## Phase 3: Blog System\n\n- [ ] 6. Create blog dynamic route\n  - Files: `app/blog/[slug]/page.tsx`, `app/blog/[slug]/metadata.ts`\n  - Implement server component that loads blog post via content API\n  - Add generateStaticParams() for static generation at build time\n  - Purpose: Core blog article page rendering\n  - _Leverage: lib/content/content-api.ts from Task 4, lib/content/mdx-compiler.ts from Task 5_\n  - _Requirements: Req 1_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: Next.js Developer with App Router expertise | Task: Create app/blog/[slug]/page.tsx as async server component. Implement: 1) generateStaticParams() that calls getAllBlogPosts() and returns array of { slug } objects, 2) Page component that calls getBlogPost(slug), returns notFound() if null, compiles MDX via compileMDXContent, renders article with proper semantic HTML (article, header, time, h1, div for content). Create app/blog/[slug]/metadata.ts exporting generateMetadata() function that loads post and returns { title: frontmatter.title, description: frontmatter.description, openGraph: {...} }. | Restrictions: Must be server component (no 'use client'), call notFound() from next/navigation for missing posts, use semantic HTML5 (article, time datetime), lazy load non-critical components | _Leverage: lib/content/content-api.ts getBlogPost(), lib/content/mdx-compiler.ts compileMDXContent(), next/navigation notFound(), existing metadata pattern from app/services/metadata.ts | _Requirements: Req 1.1, 1.2, 1.3 (blog routes, static generation, metadata) | Success: Blog articles render correctly, static params generate all routes, metadata populates correctly, 404 for missing posts. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n- [ ] 7. Create MDXContent renderer component\n  - File: `components/content/MDXContent.tsx`\n  - Create wrapper component for MDX output with custom styling\n  - Add custom components for MDX (Image, Link, CodeBlock, etc.)\n  - Purpose: Styled MDX rendering with custom components\n  - _Leverage: next/image, next/link, Tailwind typography plugin_\n  - _Requirements: Req 1, Req 7_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: React Developer with component composition expertise | Task: Create MDXContent.tsx that wraps MDX output in styled div with Tailwind prose classes. Provide custom MDX components: { img: (props) => <Image {...props} using next/image with responsive sizes, a: (props) => <Link {...props} using next/link for internal links, code: inline code with bg-gray-100 styling, pre: code block wrapper with copy button }. Export as default function accepting { children: React.ReactNode }. Add prose prose-lg prose-slate class for typography. | Restrictions: Use next/image for all images (auto WebP/AVIF), next/link for internal links only, inline code needs distinct styling from blocks, add \"Copy\" button to code blocks (client component), responsive image sizes attribute | _Leverage: next/image component, next/link component, Tailwind @tailwindcss/typography plugin, existing button component from components/ui/button.tsx | _Requirements: Req 1.5 (image optimization), Req 7.4 (WebP/AVIF), Req 7 (reading experience) | Success: MDX renders with proper styling, images optimized automatically, internal links use next/link, code blocks have copy button, responsive typography. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n- [ ] 8. Create TableOfContents component\n  - File: `components/content/TableOfContents.tsx`\n  - Build client component that extracts H2/H3 headings and creates sticky ToC\n  - Add scroll-spy to highlight current section\n  - Purpose: Navigation for long articles\n  - _Leverage: React hooks (useState, useEffect), rehypeSlug IDs from Task 5_\n  - _Requirements: Req 7_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: Frontend Developer with React hooks expertise | Task: Create 'use client' component that accepts `items: TOCItem[]` (from design.md line 298). Render sticky sidebar with links to headings using anchor IDs from rehypeSlug. Implement scroll-spy with IntersectionObserver to track visible heading and highlight in ToC. Render as sticky right sidebar on desktop (hidden on mobile via Tailwind lg:block). Style with Tailwind: sticky top-24 right-0 w-64, smooth scroll behavior. | Restrictions: Must be client component, use IntersectionObserver API for scroll-spy (not scroll events), extract heading IDs from document after mount, highlight active section with accent color, smooth scroll on click (scroll-behavior: smooth) | _Leverage: React hooks (useState, useEffect, useRef), IntersectionObserver API, Tailwind CSS positioning, existing accent colors from globals.css | _Requirements: Req 7.3 (Table of Contents generation) | Success: ToC renders with all H2/H3 headings, scroll-spy highlights current section, smooth scroll on click, sticky positioning works, hidden on mobile. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n- [ ] 9. Create ReadingProgress component\n  - File: `components/content/ReadingProgress.tsx`\n  - Build client component with progress bar showing scroll position\n  - Add to Header for long articles (>2000 words)\n  - Purpose: UX enhancement for long reads\n  - _Leverage: React hooks, Framer Motion, existing Header component_\n  - _Requirements: Req 7_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: Frontend Developer with animation expertise | Task: Create 'use client' component that tracks scroll progress through article content. Use useEffect with scroll listener to calculate percentage scrolled (scrollTop / (scrollHeight - clientHeight) * 100). Render Framer Motion div with fixed positioning (top-0 left-0 z-50) and animated width based on progress. Style as thin bar (h-1) with gradient from accent to secondary color. Export function accepting optional threshold prop (default 2000 words - only show if article longer). | Restrictions: Must be client component, debounce scroll listener for performance (max 60fps), remove listener on unmount, only calculate from article content (not full page), use transform/opacity for animations (GPU accelerated), check word count before rendering | _Leverage: React hooks (useState, useEffect), Framer Motion motion.div, existing gradient colors from globals.css, scroll event debouncing | _Requirements: Req 7.5 (Reading Progress Bar for content > 2000 words) | Success: Progress bar animates smoothly, shows correct scroll percentage, debounced for performance, only shows for long articles, GPU-accelerated animations. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n- [ ] 10. Create RelatedArticles component\n  - File: `components/content/RelatedArticles.tsx`\n  - Build server component showing 3-4 related posts based on tags\n  - Add simple recommendation algorithm (shared tags > same category > recent)\n  - Purpose: Content discovery and internal linking\n  - _Leverage: lib/content/content-api.ts getRelatedBlogPosts()_\n  - _Requirements: Req 1_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: Backend Developer with recommendation algorithms | Task: Create async server component that accepts currentSlug and tags props. Call getRelatedBlogPosts(currentSlug, 4) from content API (implement this in Task 4 if not done). Algorithm: 1) filter out current post, 2) score posts by shared tags count (1 point per tag), 3) boost same category by 0.5, 4) sort by score desc, 5) take top 4, 6) if <4 results add recent posts. Render as grid with card for each: thumbnail image, title, excerpt (first 120 chars), reading time, tags. Link to /blog/{slug}. | Restrictions: Server component (no 'use client'), max 4 related posts, graceful fallback if <4 related (show recent posts), truncate long excerpts with ellipsis, lazy load images with next/image, use existing card styles from BlogContent.tsx | _Leverage: lib/content/content-api.ts (extend with getRelatedBlogPosts), next/link for article links, next/image for thumbnails, existing blog card styles from components/sections/BlogContent.tsx (lines 136-187) | _Requirements: Req 1.4 (Related Articles) | Success: Shows 4 related articles, recommendation algorithm works (shared tags prioritized), cards styled consistently, links work, images lazy loaded. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n- [ ] 11. Update blog overview page\n  - Files: `app/blog/page.tsx`, `components/sections/BlogContent.tsx`\n  - Replace mock posts array with real content from content API\n  - Add pagination, category filter, and search\n  - Purpose: Dynamic blog listing with real content\n  - _Leverage: lib/content/content-api.ts getAllBlogPosts(), existing BlogContent.tsx_\n  - _Requirements: Req 1, Req 7_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: Full-stack Developer with pagination expertise | Task: Convert app/blog/page.tsx to async server component that calls getAllBlogPosts(). Replace mock posts array in components/sections/BlogContent.tsx with posts prop. Implement pagination: use searchParams for page number, show 12 posts per page, render prev/next buttons. Add category filter: extract unique categories from all posts, render filter buttons (client component), update search params on click. Add simple search: input filters posts by title/description match (case-insensitive). Keep existing card UI from lines 136-187 but use real post data. | Restrictions: Server component for data loading, client component for filters/search (mark with 'use client'), use Next.js searchParams for pagination state, maintain existing animation and gradient background from BlogContent.tsx, pagination via /blog?page=2 URLs (not client state), debounce search input 300ms | _Leverage: lib/content/content-api.ts getAllBlogPosts(), existing BlogContent.tsx UI (keep gradient bg and animations), Next.js searchParams API, React useState for search input | _Requirements: Req 1.4 (article overview, pagination, filter, search), Req 7.2 (response time < 500ms) | Success: Real blog posts render correctly, pagination works with URL params, category filter updates results, search filters posts, 12 posts per page, < 500ms response time. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n## Phase 4: Portfolio System\n\n- [ ] 12. Create portfolio dynamic route\n  - Files: `app/portfolio/[slug]/page.tsx`, `app/portfolio/[slug]/metadata.ts`\n  - Implement server component for portfolio case studies\n  - Add generateStaticParams() for all projects\n  - Purpose: Portfolio project detail pages\n  - _Leverage: lib/content/content-api.ts getPortfolioProject(), existing PortfolioContent.tsx patterns_\n  - _Requirements: Req 2_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: Next.js Developer with portfolio design expertise | Task: Create app/portfolio/[slug]/page.tsx as async server component. Implement: 1) generateStaticParams() calling getAllPortfolioProjects() returning { slug }[], 2) Page component loading getPortfolioProject(slug), notFound() if null, compiling MDX, rendering case study with sections: hero (client name, title, image), metrics cards (value, label, improvement in grid), testimonial if present (quote, author, rating as stars), tech stack (tags as badges), MDX content (challenge, solution, results), CTA back to portfolio. Create metadata.ts exporting generateMetadata() with title, description, OG image. | Restrictions: Server component, semantic HTML (article for case study, figure for images), metrics as grid of cards with gradient backgrounds, testimonial with 5-star rating visual, tech badges with icon colors, use existing BeforeAfterSlider from PortfolioContent.tsx if applicable | _Leverage: lib/content/content-api.ts getPortfolioProject(), components/showcase/BeforeAfterSlider.tsx for before/after, existing card styles, next/image for project images, Lucide icons for tech stack | _Requirements: Req 2.1, 2.2, 2.3 (portfolio routes, case studies, metrics, testimonials) | Success: Portfolio projects render fully, metrics displayed as cards, testimonials show rating stars, tech stack as badges, before/after slider works if present, metadata correct. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n- [ ] 13. Update portfolio overview page\n  - Files: `app/portfolio/page.tsx`, `components/sections/PortfolioContent.tsx`\n  - Replace mock projects with real content from API\n  - Add category filter (Web, Mobile, UI/UX, Full-Stack)\n  - Purpose: Dynamic portfolio listing\n  - _Leverage: lib/content/content-api.ts getAllPortfolioProjects(), existing PortfolioContent.tsx_\n  - _Requirements: Req 2_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: Frontend Developer with filter UI expertise | Task: Convert app/portfolio/page.tsx to async server component calling getAllPortfolioProjects(). Update components/sections/PortfolioContent.tsx to accept projects prop. Replace mock projects array (lines 156-189) with real data. Keep existing BeforeAfterSlider and AppShowcase for special projects. Add category filter at top: buttons for \"All\", \"Web\", \"Mobile\", \"UI/UX\", \"Full-Stack\" that filter projects on click (client component). Maintain existing gradient background and card styles. Link each project card to /portfolio/{slug} with \"View Case Study\" button. | Restrictions: Keep existing project showcases (SV Viktoria with BeforeAfterSlider, KLARTEXT with AppShowcase), filter must be client component ('use client'), update filter state on click, maintain gradient animation background from lines 193-194, use existing card styles from lines 205-235 | _Leverage: lib/content/content-api.ts getAllPortfolioProjects(), existing BeforeAfterSlider component (keep), existing gradient background (keep), React useState for filter state | _Requirements: Req 2.3 (portfolio overview with filters) | Success: Real portfolio projects render, filter by category works, special showcase components preserved, links to detail pages work, gradient background maintained. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n## Phase 5: Service Detail Pages\n\n- [ ] 14. Create service detail dynamic route\n  - Files: `app/services/[slug]/page.tsx`, `app/services/[slug]/metadata.ts`\n  - Implement server component for service deep-dives\n  - Add generateStaticParams() for 4 services (web-development, mobile-development, ui-ux-design, backend-solutions)\n  - Purpose: SEO-optimized service pages with 2000+ words\n  - _Leverage: lib/content/content-api.ts getServicePage(), existing ServicesContent.tsx_\n  - _Requirements: Req 3_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: Next.js Developer with SEO expertise | Task: Create app/services/[slug]/page.tsx async server component. Implement: 1) generateStaticParams() returning [{ slug: 'web-development' }, { slug: 'mobile-development' }, { slug: 'ui-ux-design' }, { slug: 'backend-solutions' }], 2) Page loading getServicePage(slug), notFound() if null, rendering: hero (title, description, icon from Lucide), pricing card (from, currency, unit), deliverables list with checkmarks, process steps timeline, MDX content (2000+ words long-form), FAQ accordion (frontmatter.faqs), related case studies (frontmatter.relatedCaseStudies), CTA. Create metadata.ts with dynamic metadata. | Restrictions: Server component, hero with large Lucide icon, pricing as card with gradient, deliverables as checklist with green checkmarks, process steps as vertical timeline, FAQ as Accordion component from ui/accordion, related case studies load projects via API and show cards, minimum 2000 words content validation in frontmatter schema | _Leverage: lib/content/content-api.ts getServicePage(), components/ui/accordion for FAQ, Lucide icons library, getRelatedPortfolioProjects() from API, existing pricing card styles from PricingSection.tsx | _Requirements: Req 3.1, 3.2 (service routes, 2000+ words, FAQ, pricing, case studies) | Success: 4 service pages generate statically, 2000+ words content, FAQ accordion works, pricing displayed, related case studies load, metadata correct. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n- [ ] 15. Create FAQ accordion component\n  - File: `components/sections/FAQSection.tsx`\n  - Build reusable FAQ component using shadcn/ui Accordion\n  - Style for SEO-optimized FAQ display\n  - Purpose: Reusable FAQ component for service pages and homepage\n  - _Leverage: components/ui/accordion.tsx, design system_\n  - _Requirements: Req 3_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: React Developer with accessible UI components | Task: Create FAQSection.tsx server component accepting `faqs: { question: string, answer: string }[]` prop. Render using shadcn Accordion component with type=\"single\" collapsible. Each AccordionItem shows question as trigger and answer as content. Style with Tailwind: questions as font-semibold text-lg, answers as prose text-gray-700, accordion items with border-b divider, hover states with bg-gray-50. Add section wrapper with heading \"Häufig gestellte Fragen\" (h2). Max 5-8 FAQs per section for optimal SEO. | Restrictions: Server component (no state needed, Accordion handles interaction), use existing Accordion from components/ui/accordion.tsx, accessible (proper ARIA), responsive design, question/answer must be semantic for SEO (use proper heading levels), 5-8 FAQs recommended per page | _Leverage: components/ui/accordion.tsx from shadcn, Tailwind prose for answer styling, existing gray color palette | _Requirements: Req 3.3 (FAQ sections), Req 5.2 (FAQPage schema compatibility) | Success: FAQ renders as accessible accordion, questions/answers styled properly, collapsible interaction works, responsive design, 5-8 FAQ limit enforced. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n## Phase 6: City Landing Pages\n\n- [ ] 16. Create city overview page with map\n  - Files: `app/standorte/page.tsx`, `components/sections/CityMap.tsx`\n  - Implement overview page showing all 6 cities with interactive map\n  - Add city cards with links to detail pages\n  - Purpose: Geographic SEO overview\n  - _Leverage: Leaflet or Mapbox GL, lib/content/content-api.ts getAllCityPages()_\n  - _Requirements: Req 4_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: Full-stack Developer with maps integration | Task: Create app/standorte/page.tsx async server component loading getAllCityPages(). Create components/sections/CityMap.tsx 'use client' component accepting cities array. Install react-leaflet and leaflet (`pnpm add react-leaflet leaflet @types/leaflet`). Render Leaflet map centered on Main-Tauber-Kreis (lat: 49.5, lng: 9.7, zoom: 10) with markers for all 6 cities (coordinates from frontmatter). On marker click, show popup with city name and link to detail page. Below map, render city cards grid (2 cols on desktop) with: city name, population, short description, \"Mehr erfahren\" button. | Restrictions: Map component must be client ('use client'), import Leaflet CSS in component, lazy load map with dynamic import, markers use accent color, popup has white background with shadow, city cards maintain existing card styling, responsive grid (1 col mobile, 2 col desktop), link to /standorte/{slug} | _Leverage: react-leaflet library, OpenStreetMap tiles (free), lib/content/content-api.ts getAllCityPages(), existing card styles, Tailwind grid | _Requirements: Req 4.3 (city overview with interactive map) | Success: Map renders with 6 city markers, marker popups show city info and link, city cards render in grid, links to detail pages work, map lazy loaded for performance. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n- [ ] 17. Create city detail dynamic route\n  - Files: `app/standorte/[city]/page.tsx`, `app/standorte/[city]/metadata.ts`\n  - Implement server component for city landing pages\n  - Add generateStaticParams() for 6 cities\n  - Purpose: Local SEO landing pages\n  - _Leverage: lib/content/content-api.ts getCityPage()_\n  - _Requirements: Req 4_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: SEO Developer with local search expertise | Task: Create app/standorte/[city]/page.tsx async server component. Implement: 1) generateStaticParams() returning 6 city slugs (bad-mergentheim, lauda-koenigshofen, tauberbischofsheim, wertheim, marktheidenfeld, wuerzburg), 2) Page loading getCityPage(slug), notFound() if null, rendering: hero (city name with state, single-city map centered on coordinates), stats section (population, state), MDX content (local services, why choose us in this region), services offered in city (from frontmatter.services, load via API), local case studies (from frontmatter.caseStudies), CTA for contact. Create metadata.ts with dynamic title containing city name and local keywords. Ensure H1 contains \"Webentwicklung in {City}\" for local SEO. | Restrictions: Server component, hero H1 MUST include \"Webentwicklung in {CityName}\" for local keyword targeting, single-city map (not interactive, use static map or single marker Leaflet), load related services from frontmatter.services array (show service cards), load local case studies from frontmatter.caseStudies (show project cards), metadata title format: \"Webentwicklung {City} | HEADON.pro\" | _Leverage: lib/content/content-api.ts getCityPage(), getServicePage() for services, getPortfolioProject() for case studies, Leaflet for city map, existing service and portfolio cards | _Requirements: Req 4.1, 4.2, 4.4 (city routes, local content, keywords in H1, local case studies) | Success: 6 city pages generate, H1 contains local keywords, city map shows location, services and case studies load correctly, metadata optimized for local SEO. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n## Phase 7: Schema.org & SEO Components\n\n- [ ] 18. Create Schema.org builder utility\n  - File: `lib/seo/schema-builder.ts`\n  - Implement functions to generate all Schema.org types: Article, FAQPage, CreativeWork, Person, Review, AggregateRating, BreadcrumbList\n  - Add type-safe Schema builders\n  - Purpose: Centralized Schema.org JSON-LD generation\n  - _Leverage: lib/types/schema.ts from Task 1_\n  - _Requirements: Req 5_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: SEO Technical Specialist with Schema.org expertise | Task: Create schema-builder.ts with functions for each schema type. Implement: `buildArticleSchema(post: BlogPost)`, `buildFAQPageSchema(faqs: FAQ[])`, `buildCreativeWorkSchema(project: PortfolioProject)`, `buildPersonSchema(person: Person)`, `buildReviewSchema(review: Review)`, `buildAggregateRatingSchema(rating: AggregateRating)`, `buildBreadcrumbListSchema(items: BreadcrumbItem[])`. Each function returns typed schema object matching Schema.org spec. Add helper `generateSchemaScript(schema: object)` that returns JSON string for <script type=\"application/ld+json\">. Validate all required Schema.org fields present. | Restrictions: All schemas must pass Google Rich Results Test, use exact Schema.org property names (@context, @type, datePublished not published_date), dates as ISO 8601 strings, images as absolute URLs (prepend baseUrl if relative), author/publisher as nested objects not strings, rating values 1-5 scale, breadcrumbs with position starting at 1 | _Leverage: lib/types/schema.ts interfaces, Schema.org documentation, existing baseUrl from environment, JSON.stringify for script generation | _Requirements: Req 5.1, 5.2, 5.3, 5.4, 5.5, 5.6 (all schema types) | Success: All schema builder functions work, output valid Schema.org JSON-LD, pass Google Rich Results Test, type-safe with TypeScript. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n- [ ] 19. Create universal SchemaGenerator component\n  - File: `components/seo/SchemaGenerator.tsx`\n  - Build wrapper component that injects Schema.org JSON-LD into page head\n  - Support all schema types from Task 18\n  - Purpose: Reusable component for Schema injection\n  - _Leverage: Next.js Script component, lib/seo/schema-builder.ts_\n  - _Requirements: Req 5_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: React Developer with SEO component expertise | Task: Create SchemaGenerator.tsx server component accepting `schema: object` prop. Use Next.js Script component with id=\"schema-{type}\", type=\"application/ld+json\", dangerouslySetInnerHTML={{ __html: JSON.stringify(schema) }}. Add validation: check schema has @context and @type, log warning if missing. Support multiple schemas on same page (unique IDs). Export as default function. Also create specific wrappers: ArticleSchema, FAQSchema, CreativeWorkSchema, PersonSchema, ReviewSchema, BreadcrumbSchema that call respective builders and render SchemaGenerator. | Restrictions: Server component, use Next.js Script with strategy=\"afterInteractive\" for SEO (not \"lazyOnload\"), validate @context and @type present before rendering, unique ID per schema type (append random string if multiple same type), escape HTML in JSON (use JSON.stringify safely), never render if schema is null/undefined | _Leverage: next/script Script component, lib/seo/schema-builder.ts functions, JSON.stringify for safe HTML escaping | _Requirements: Req 5 (all schema types), design.md Component 2 (lines 275-283) | Success: SchemaGenerator renders valid JSON-LD script tags, multiple schemas per page work, type-safe props, validation warnings logged, no hydration errors. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n- [ ] 20. Create enhanced Breadcrumbs component\n  - File: `components/seo/Breadcrumbs.tsx`\n  - Build breadcrumb navigation with Schema.org BreadcrumbList\n  - Add to all content pages\n  - Purpose: Navigation aid and SEO signal\n  - _Leverage: lib/seo/schema-builder.ts buildBreadcrumbListSchema(), components/seo/SchemaGenerator.tsx_\n  - _Requirements: Req 5, Req 6_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: Frontend Developer with accessibility and SEO | Task: Create Breadcrumbs.tsx server component accepting `items: { name: string, url: string }[]` prop. Render nav element with ol list of breadcrumb links. Each item: li with Link component to url, chevron separator (Lucide ChevronRight icon) between items (not after last). Last item without link (current page). Render SchemaGenerator with buildBreadcrumbListSchema(items). Style with Tailwind: text-sm text-gray-600, hover:text-primary on links, current page as font-semibold text-gray-900. | Restrictions: Server component, semantic HTML (nav, ol, li), last item not clickable, separator between items (not after last), include Schema.org BreadcrumbList on same render, accessible (aria-label=\"Breadcrumb\" on nav), responsive (truncate long names with ellipsis on mobile), use next/link for navigation | _Leverage: next/link Link component, Lucide ChevronRight icon, lib/seo/schema-builder.ts buildBreadcrumbListSchema(), components/seo/SchemaGenerator.tsx, Tailwind ellipsis utility | _Requirements: Req 5.6 (BreadcrumbList schema), Req 6 (breadcrumbs on all pages) | Success: Breadcrumbs render correctly, Schema.org BreadcrumbList included, accessible navigation, responsive truncation, styled with hover states. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n- [ ] 21. Integrate schemas into all content pages\n  - Files: `app/blog/[slug]/page.tsx`, `app/portfolio/[slug]/page.tsx`, `app/services/[slug]/page.tsx`, `app/about/page.tsx`\n  - Add appropriate Schema.org markup to each page type\n  - Add Breadcrumbs to all pages\n  - Purpose: Complete Schema.org coverage\n  - _Leverage: All schema components from Tasks 18-20_\n  - _Requirements: Req 5_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: SEO Integration Specialist | Task: Add Schema.org components to each page type: 1) Blog articles: ArticleSchema (author, datePublished, dateModified, image), 2) Portfolio: CreativeWorkSchema (dateCreated, author, keywords from tags), Review if testimonial present, 3) Services: Service schema (existing), FAQSchema from frontmatter.faqs, Offer schema from pricing, 4) About: Person schema for founder (Onur Cirakoglu), Organization schema (existing). Add Breadcrumbs to all pages: Blog (/→/blog→/blog/{slug}), Portfolio (/→/portfolio→/portfolio/{slug}), Services (/→/services→/services/{slug}), Cities (/→/standorte→/standorte/{city}). Build breadcrumb items dynamically from route. | Restrictions: Server components, schemas render in page component (not layout), breadcrumbs at top of main content (before hero), author object must include @type Person and name, publisher must be Organization with logo, all dates ISO 8601, image URLs absolute, Review schema only if testimonial exists (conditional rendering) | _Leverage: components/seo/ArticleSchema, CreativeWorkSchema, FAQSchema, PersonSchema, ReviewSchema, Breadcrumbs components, lib/seo/schema-builder.ts functions | _Requirements: Req 5.1, 5.2, 5.3, 5.4, 5.5 (all content schemas), Req 6 (breadcrumbs) | Success: All page types have appropriate schemas, breadcrumbs on all pages, schemas pass Google Rich Results Test, conditional schemas work. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n## Phase 8: Dynamic Sitemap & RSS\n\n- [ ] 22. Create dynamic sitemap generator\n  - File: `app/sitemap.ts`\n  - Replace static sitemap with dynamic generator\n  - Include all blog, portfolio, service, city pages\n  - Purpose: Automatic sitemap updates with new content\n  - _Leverage: lib/content/content-api.ts, existing sitemap.ts structure_\n  - _Requirements: Req 6_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: SEO Technical Developer with Next.js sitemap expertise | Task: Rewrite app/sitemap.ts as async function returning MetadataRoute.Sitemap array. Load content: 1) getAllBlogPosts(), 2) getAllPortfolioProjects(), 3) getAllServicePages(), 4) getAllCityPages(). Build sitemap entries for each with: url (full absolute URL with baseUrl), lastModified (updatedAt or publishedAt), changeFrequency (blog: weekly, portfolio: monthly, services: monthly, cities: monthly), priority (blog: 0.8, portfolio: 0.7, services: 0.9, cities: 0.7). Add static pages (/, /services, /portfolio, /about, /contact, /blog with priorities). Export maxDuration = 30 and revalidate = 3600 for caching. | Restrictions: Must be async function, fetch all content with Promise.all for parallel loading, use absolute URLs (include NEXT_PUBLIC_SITE_URL env), dates as Date objects or ISO strings, priority 0.0-1.0, changeFrequency from allowed values, cache for 1 hour (revalidate: 3600), timeout 30 seconds max, no pagination for sitemap (single file up to 50k URLs) | _Leverage: lib/content/content-api.ts all getAll functions, process.env.NEXT_PUBLIC_SITE_URL, Next.js MetadataRoute.Sitemap type, existing sitemap structure from app/sitemap.ts | _Requirements: Req 6.1 (dynamic sitemap with all pages) | Success: Sitemap includes all content pages dynamically, updates on new content, URLs absolute, metadata correct, cached for 1 hour, passes sitemap validators. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n- [ ] 23. Create image sitemap\n  - File: `app/image-sitemap.xml/route.ts`\n  - Implement dynamic image sitemap for portfolio and blog images\n  - Follow Google image sitemap spec\n  - Purpose: Better indexing of portfolio screenshots and blog images\n  - _Leverage: lib/content/content-api.ts_\n  - _Requirements: Req 6_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: SEO Developer with XML and image sitemap expertise | Task: Create app/image-sitemap.xml/route.ts with async GET function. Load: 1) getAllBlogPosts(), 2) getAllPortfolioProjects(). Extract images: blog post image from frontmatter.image.url, portfolio image from frontmatter.image.url. Build XML following Google image sitemap spec: root urlset element, url element per page, image:image element per image with image:loc (absolute URL), image:caption (alt text), image:title (title). Return NextResponse with XML string and headers: { 'Content-Type': 'application/xml', 'Cache-Control': 'public, max-age=3600' }. Add to sitemap index via robots.txt or main sitemap. | Restrictions: Valid XML format, absolute image URLs (prepend baseUrl if relative), escape XML special characters (&, <, >, \", '), namespace xmlns:image=\"http://www.google.com/schemas/sitemap-image/1.1\", cache for 1 hour, max 1000 images per sitemap (paginate if needed), only include actual images (not icons/logos) | _Leverage: lib/content/content-api.ts getAll functions, Next.js Route Handlers (route.ts), XML string building, process.env.NEXT_PUBLIC_SITE_URL | _Requirements: Req 6.2 (image sitemap) | Success: Image sitemap generates valid XML, includes all blog/portfolio images, absolute URLs, XML escaping correct, cached properly, passes XML validators. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n- [ ] 24. Create RSS feed\n  - File: `app/rss.xml/route.ts`\n  - Implement RSS 2.0 feed for blog posts\n  - Include latest 20 articles\n  - Purpose: Content syndication and reader apps\n  - _Leverage: lib/content/content-api.ts getAllBlogPosts()_\n  - _Requirements: Req 6_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: Backend Developer with RSS/XML expertise | Task: Create app/rss.xml/route.ts with async GET function. Load getAllBlogPosts() sorted by date desc, take first 20. Build RSS 2.0 XML: root rss element (version=\"2.0\"), channel with: title (\"HEADON.pro Blog\"), description, link (baseUrl/blog), language (\"de\"), lastBuildDate (now), item elements per post with: title, link (absolute URL), description (excerpt or first 200 chars of content), pubDate (RFC 822 format), guid (link, isPermaLink=\"true\"), category per tag. Return NextResponse with XML and headers: { 'Content-Type': 'application/xml', 'Cache-Control': 'public, max-age=3600' }. | Restrictions: RSS 2.0 spec compliant, valid XML with proper escaping, pubDate in RFC 822 format (use .toUTCString()), absolute URLs, latest 20 posts only (desc by date), description plain text (strip MDX/HTML), guid must be unique and permanent (use post URL), cache 1 hour, language code \"de\" | _Leverage: lib/content/content-api.ts getAllBlogPosts(), Next.js Route Handlers, Date.prototype.toUTCString() for RFC 822 dates, XML escaping functions | _Requirements: Req 6.3 (RSS feed) | Success: RSS feed generates valid RSS 2.0 XML, includes latest 20 posts, dates RFC 822 format, passes RSS validators, cached properly, readable in feed readers. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n## Phase 9: Error Pages & Polish\n\n- [ ] 25. Create custom 404 page\n  - File: `app/not-found.tsx`\n  - Design branded 404 page with search and navigation\n  - Add helpful links to main sections\n  - Purpose: Better UX for missing pages\n  - _Leverage: existing Header/Footer, components/ui/button_\n  - _Requirements: Req 6_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: UI/UX Developer with error page design | Task: Create app/not-found.tsx as client component ('use client') with branded 404 page. Include: hero section with 404 illustration (use Lucide FileQuestion icon large), heading \"Seite nicht gefunden\", friendly message \"Die gesuchte Seite existiert leider nicht.\", search input (future: could search blog), quick links section with cards to: Homepage, Blog, Portfolio, Services, Contact (use Link and Button components). Style with existing gradient background pattern from HeroSection.tsx. Add simple animation on mount (Framer Motion fadeIn). | Restrictions: Must be named not-found.tsx (Next.js convention), use 'use client' for animations/interactions, include helpful navigation not just error message, maintain brand consistency (colors, fonts, layout), search can be placeholder/future enhancement (just UI), use existing components (Button, Link), gradient background like other pages, Framer Motion for subtle animations, no external 404 images (use Lucide icon) | _Leverage: Lucide FileQuestion icon, components/ui/button, next/link, Framer Motion, existing gradient background from HeroSection, Tailwind styling | _Requirements: Req 6.4 (custom 404 page with navigation) | Success: 404 page renders with branding, helpful links work, search UI present (even if non-functional), animations smooth, responsive design, maintains site look/feel. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n- [ ] 26. Create custom 500 error page\n  - File: `app/error.tsx`\n  - Design branded error page with status info\n  - Add reset button and support contact\n  - Purpose: Better UX for server errors\n  - _Leverage: Next.js error.tsx conventions_\n  - _Requirements: Req 6_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: Frontend Developer with error handling expertise | Task: Create app/error.tsx as client component ('use client') accepting { error, reset } props (Next.js convention). Display: error illustration (Lucide AlertTriangle large), heading \"Etwas ist schiefgelaufen\", user-friendly message, technical details in collapsed accordion (error.message, only in dev mode via process.env.NODE_ENV), \"Try Again\" button calling reset(), \"Contact Support\" link to /contact with mailto:hallo@headon.pro fallback. Style with gradient background, Framer Motion animations. Log error to console in production. | Restrictions: Must be named error.tsx (Next.js convention), 'use client' required, accept error and reset props from Next.js, error.message only shown in development (hide in production), reset() retries rendering the segment, include support contact (email or contact page link), maintain brand styling, log errors for debugging, handle error gracefully without exposing sensitive info | _Leverage: Lucide AlertTriangle icon, components/ui/button, next/link, Framer Motion, process.env.NODE_ENV for dev/prod check, console.error for logging | _Requirements: Req 6.5 (custom 500 error page) | Success: Error page renders on errors, reset button retries, error details hidden in prod, support contact visible, animations work, logs errors for debugging. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n- [ ] 27. Add meta description helper\n  - File: `lib/seo/meta-builder.ts`\n  - Create utility functions for consistent meta tag generation\n  - Add truncation and optimization helpers\n  - Purpose: Ensure all meta tags follow SEO best practices\n  - _Leverage: existing metadata patterns_\n  - _Requirements: All requirements (meta tags everywhere)_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: SEO Developer with metadata optimization | Task: Create meta-builder.ts with helper functions: 1) `truncateTitle(title: string, maxLength = 60)` - truncates and adds ellipsis, 2) `truncateDescription(desc: string, maxLength = 160)` - same for description, 3) `buildMetaTags({ title, description, image, url, type })` - returns full Metadata object with title, description, openGraph, twitter (if applicable), alternates.canonical, 4) `generatePageMetadata(content: BlogPost | PortfolioProject | etc.)` - extracts meta from content frontmatter. Ensure: title 50-60 chars, description 150-160 chars, OpenGraph images absolute URLs, canonical URLs, structured format. | Restrictions: Title max 60 chars (Google cutoff), description max 160 chars, preserve word boundaries when truncating (don't cut words), absolute URLs for images (prepend baseUrl if relative), canonical URLs always set, OpenGraph type appropriate (article, website, etc.), Twitter cards optional (only if Twitter account in env), no duplicate meta tags | _Leverage: String.prototype.slice() for truncation, process.env.NEXT_PUBLIC_SITE_URL for base URL, existing metadata patterns from app/services/metadata.ts | _Requirements: All (meta tags on all pages), design.md non-functional req SEO (lines 754-755) | Success: Helper functions truncate correctly, buildMetaTags generates complete Metadata objects, all URLs absolute, canonical set, titles/descriptions optimal length. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n## Phase 10: Initial Content Creation\n\n- [ ] 28. Create initial blog content (15 articles)\n  - Files: `content/blog/*.mdx`\n  - Write 15 SEO-optimized blog articles (800-2000 words each)\n  - Cover topics: Web Development, Performance, Next.js, React, UI/UX, Mobile\n  - Purpose: Seed content for SEO launch\n  - _Leverage: MDX format, frontmatter schemas from Task 2_\n  - _Requirements: Req 1, content requirements from requirements.md_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: Technical Content Writer with SEO expertise | Task: Create 15 blog articles as MDX files in content/blog/. Topics distribution: 4 articles on Next.js/React (Next.js 15 features, React 19, performance optimization, SSR vs CSR), 3 on Web Performance (Core Web Vitals, image optimization, caching strategies), 3 on UI/UX (design systems, accessibility, mobile-first), 3 on Mobile Development (React Native, PWA, responsive design), 2 on Business/Agency (agency selection, web project planning). Each article: 800-2000 words, complete frontmatter (title, description, author, publishedAt, tags, category, image, readingTime), SEO-optimized (keywords in H1/H2, internal links, external authority links), code examples with syntax highlighting, images in public/images/blog/, clear structure (intro, body, conclusion). File names: kebab-case matching slug. | Restrictions: All frontmatter must pass Zod validation from Task 2, publishedAt dates realistic (spread over last 6 months), reading time accurate (words/200), images must exist in public/images/blog/, author name \"Onur Cirakoglu\", category from enum (development, design, performance, mobile), min 3 tags per article, description 150-160 chars, h1 only once (title), h2-h6 for structure, code blocks with language specified for syntax highlighting, internal links to other blog posts/services where relevant | _Leverage: MDX format, gray-matter frontmatter, lib/content/frontmatter.ts validation schemas, Markdown/MDX syntax, code block syntax highlighting from rehype-pretty-code | _Requirements: Req 1, content requirements \"Min. 15 initial articles with 800-2000 words\" | Success: 15 MDX files created, all frontmatter validates, 800-2000 words each, SEO-optimized structure, code examples included, images present, reading time accurate. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n- [ ] 29. Create portfolio case studies (6 projects)\n  - Files: `content/portfolio/*.mdx`\n  - Write 6 detailed case studies with metrics and testimonials\n  - Cover all categories: Web, Mobile, UI/UX, Full-Stack\n  - Purpose: Showcase work with SEO-optimized case studies\n  - _Leverage: MDX format, frontmatter schemas from Task 2_\n  - _Requirements: Req 2, content requirements_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: Portfolio Content Specialist | Task: Create 6 portfolio case studies as MDX files in content/portfolio/. Projects distribution: 2 Web (SV Viktoria Wertheim already exists, add 1 more), 2 Mobile (KLARTEXT App already exists, add 1 more), 1 UI/UX, 1 Full-Stack. Each case study: complete frontmatter (title, description, client info with logo/industry, date, category, tags, image, metrics array with 3-5 metrics, testimonial with quote/author/role/rating), 1000-1500 words content with sections: Challenge, Solution (with technical approach), Results (metrics), Technologies Used. Metrics format: { label: \"Performance\", value: \"95\", improvement: \"+25%\" }. Include before/after images, tech stack details, clear outcomes. File names: kebab-case client-project format. | Restrictions: All frontmatter validates, client names realistic (anonymize if needed), metrics realistic and specific (not vague), testimonials 2-3 sentences, rating 4-5 stars (we only show good projects), date within last 2 years, category from enum (web, mobile, ui-ux, full-stack), min 5 tags (technologies), images must exist in public/images/portfolio/, liveUrl and githubUrl optional (only if shareable), professional tone, focus on results and impact | _Leverage: MDX format, lib/content/frontmatter.ts validation schemas, existing SV Viktoria and KLARTEXT projects as examples, metrics format from design.md (line 329) | _Requirements: Req 2, content requirements \"Min. 6 Portfolio-Projekte with full details\" | Success: 6 case study MDX files, all frontmatter validates, 1000-1500 words each, metrics in correct format, testimonials included, images present, covers all categories. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n- [ ] 30. Create service pages content (4 services)\n  - Files: `content/services/*.mdx`\n  - Write 4 in-depth service pages (2000+ words each)\n  - Include FAQs, deliverables, process steps, pricing\n  - Purpose: SEO-optimized service pages for rankings\n  - _Leverage: MDX format, frontmatter schemas from Task 2_\n  - _Requirements: Req 3, content requirements_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: Technical Writer with service page expertise | Task: Create 4 service page MDX files in content/services/: web-development.mdx, mobile-development.mdx, ui-ux-design.mdx, backend-solutions.mdx. Each service: complete frontmatter (title, description, icon Lucide name, pricing object with from/currency/unit, deliverables array 5-8 items, processSteps array 3-4 steps with title/description/duration, faqs array 5-8 questions, relatedCaseStudies array 2-3 slugs), 2000-3000 words content with sections: Overview, What We Offer, Our Approach, Technologies We Use, Why Choose Us, Industry Applications, Success Stories (brief, link to portfolio). FAQs must be realistic client questions with detailed answers. Pricing realistic (web-development from 5000 EUR/project, mobile from 8000, ui-ux from 3000, backend from 4000). Process steps total to realistic timeline. | Restrictions: Minimum 2000 words content (validate), all frontmatter validates, icon must be valid Lucide icon name (Code2, Smartphone, Palette, Database), pricing from amount realistic for German market, deliverables concrete not vague, processSteps with realistic durations (sum to project timeline), FAQs 5-8 specific questions (good for Featured Snippets), relatedCaseStudies use actual slugs from Task 29, professional yet approachable tone, keyword-optimized (service name in H1, H2), internal links to blog/portfolio where relevant | _Leverage: MDX format, lib/content/frontmatter.ts validation schemas, existing services data from components/sections/ServicesContent.tsx (lines 9-54), Lucide icon names | _Requirements: Req 3, content requirements \"4 Seiten with 2000+ words, Min. 25 FAQs across all service pages\" | Success: 4 service MDX files, 2000+ words each, all frontmatter validates, 5-8 FAQs each (25+ total), pricing realistic, process steps complete, related case studies linked. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n- [ ] 31. Create city landing pages (6 cities)\n  - Files: `content/cities/*.mdx`\n  - Write 6 local SEO pages for Main-Tauber region\n  - Include local keywords, services, case studies\n  - Purpose: Local SEO domination for 6 target cities\n  - _Leverage: MDX format, frontmatter schemas from Task 2_\n  - _Requirements: Req 4, content requirements_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: Local SEO Content Writer | Task: Create 6 city page MDX files in content/cities/: bad-mergentheim.mdx, lauda-koenigshofen.mdx, tauberbischofsheim.mdx, wertheim.mdx, marktheidenfeld.mdx, wuerzburg.mdx. Each city: complete frontmatter (name, state Baden-Württemberg, coordinates lat/lng accurate from Google Maps, population accurate from Wikipedia, description 2-3 sentences, services array with 2-3 service slugs, caseStudies array with 1-2 project slugs if applicable, localKeywords array with 5-10 local keyword phrases like \"Webentwicklung Bad Mergentheim\", \"App Entwicklung Main-Tauber-Kreis\", etc.), 800-1200 words content with sections: About {City}, Why HEADON in {City}, Services We Offer in {City}, Local Success Stories (if applicable), Contact Us. Natural local keyword integration (not keyword stuffing). Mention local businesses/industries (wine region, tourism, manufacturing) where relevant. Professional but friendly local tone. | Restrictions: All frontmatter validates, coordinates accurate (verify on map), population from reliable source current, localKeywords realistic search terms (check Google), services array uses actual service slugs, caseStudies array uses actual project slugs (only if relevant), 800-1200 words per city, H1 format \"Webentwicklung {City} | HEADON.pro\", natural keyword density (2-3% for main keyword), mention regional context (Main-Tauber-Kreis, Neckar-Odenwald, etc.), local business categories relevant to each city | _Leverage: MDX format, lib/content/frontmatter.ts validation schemas, Google Maps for coordinates, local research for city context | _Requirements: Req 4, content requirements \"6 Seiten with 800+ words local content\" | Success: 6 city MDX files, 800-1200 words each, coordinates accurate, local keywords natural, frontmatter validates, linked to relevant services/projects, local context included. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n## Phase 11: Final Integration & Validation\n\n- [ ] 32. Update robots.txt and add sitemap references\n  - File: `app/robots.ts`\n  - Add image-sitemap.xml reference\n  - Verify all sitemaps are discoverable\n  - Purpose: Ensure search engines find all sitemaps\n  - _Leverage: existing app/robots.ts_\n  - _Requirements: Req 6_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: SEO Configuration Specialist | Task: Update app/robots.ts to add image sitemap reference. Modify existing robots() function to return object with: rules (keep existing), sitemap as array: [`${baseUrl}/sitemap.xml`, `${baseUrl}/image-sitemap.xml`], host: baseUrl. Verify all sitemaps are referenced. Test by visiting /robots.txt and confirming output includes both sitemap URLs. Also verify sitemap.xml and image-sitemap.xml are accessible. | Restrictions: sitemap can be string or array in Next.js, use array for multiple sitemaps, URLs must be absolute with baseUrl, both sitemaps must be accessible before adding to robots.txt, maintain existing rules (allow /, disallow /api/, /admin/, etc.), test robots.txt output manually | _Leverage: existing app/robots.ts structure, process.env.NEXT_PUBLIC_SITE_URL, Next.js MetadataRoute.Robots type | _Requirements: Req 6 (all sitemaps discoverable) | Success: robots.txt includes both sitemaps, sitemaps accessible at URLs, rules maintained, absolute URLs used. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n- [ ] 33. Build verification and manual testing\n  - Task: Run production build and verify all routes work\n  - Test all dynamic routes, schemas, sitemaps\n  - Fix any build errors\n  - Purpose: Ensure everything works before deployment\n  - _Leverage: pnpm build, pnpm start, browser testing_\n  - _Requirements: All_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: QA Engineer with manual testing expertise | Task: Run `pnpm build` to generate production build. Verify build succeeds without errors. Fix any TypeScript, ESLint, or build errors. Run `pnpm start` to start production server. Manually test: 1) All blog articles load (/blog, /blog/{slug}), 2) All portfolio projects load (/portfolio, /portfolio/{slug}), 3) All service pages load (/services, /services/{slug}), 4) All city pages load (/standorte, /standorte/{city}), 5) Sitemaps generate (/sitemap.xml, /image-sitemap.xml), 6) RSS feed generates (/rss.xml), 7) Schemas appear in page source (view source, search for \"application/ld+json\"), 8) 404 page works (visit /nonexistent), 9) Error page works (trigger error if possible). Use Chrome DevTools to check: no console errors, Lighthouse score 95+, LCP < 1.5s, no layout shifts. Document any issues found. | Restrictions: Must test production build (not dev), test all dynamic routes systematically, verify schemas in page source (not just rendered), test 404 and error pages, run Lighthouse on 3-5 representative pages, check Web Vitals, verify images load with WebP/AVIF, test breadcrumbs and navigation, verify all internal links work, check responsive design on mobile viewport | _Leverage: pnpm build and start commands, Chrome DevTools, Lighthouse, view-source in browser, manual clicking/navigation | _Requirements: All requirements (complete system test) | Success: Production build succeeds, all routes load correctly, schemas present in source, Lighthouse 95+, LCP < 1.5s, no console errors, 404/error pages work, responsive design verified. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n- [ ] 34. SEO validation with Google tools\n  - Task: Validate schemas with Google Rich Results Test\n  - Verify sitemaps with XML validators\n  - Test RSS feed with validators\n  - Purpose: Ensure all SEO markup is valid before launch\n  - _Leverage: Google Rich Results Test, Google Search Console (if available), XML validators, RSS validators_\n  - _Requirements: Req 5, Req 6_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: SEO Validation Specialist | Task: Validate all SEO implementations: 1) Google Rich Results Test: Test blog article, portfolio project, service page URLs (use deployed URL or localhost via ngrok if needed). Verify Article, FAQPage, CreativeWork, BreadcrumbList schemas pass without errors. 2) XML Sitemap Validator: Test /sitemap.xml at https://www.xml-sitemaps.com/validate-xml-sitemap.html. Verify valid XML, all URLs absolute, proper structure. 3) Image Sitemap Validator: Test /image-sitemap.xml similarly. 4) RSS Validator: Test /rss.xml at https://validator.w3.org/feed/. Verify RSS 2.0 compliance. 5) Schema.org Validator: Test JSON-LD at https://validator.schema.org/. Fix any validation errors found. Document all test results and fixes. | Restrictions: Use actual validator tools not just code inspection, test with production-like URLs (deploy to staging or use ngrok if localhost), all schemas must pass with 0 errors (warnings acceptable), fix errors before marking complete, document which pages tested and results, test at least 2 pages of each content type (blog, portfolio, service, city), verify Rich Results preview looks correct (images, titles, descriptions) | _Leverage: Google Rich Results Test (https://search.google.com/test/rich-results), XML Sitemap Validator (https://www.xml-sitemaps.com/validate-xml-sitemap.html), RSS Validator (https://validator.w3.org/feed/), Schema.org Validator (https://validator.schema.org/) | _Requirements: Req 5 (schema validation), Req 6 (sitemap validation), design.md testing strategy (lines 746-761) | Success: All schemas pass Rich Results Test with 0 errors, sitemaps pass XML validation, RSS passes validator, Schema.org validation clean, documentation complete. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n\n- [ ] 35. Documentation and README update\n  - Files: `CLAUDE.md`, `README.md` (if needed)\n  - Document new content structure and SEO features\n  - Add instructions for adding new content\n  - Purpose: Enable future content creation and maintenance\n  - _Leverage: existing CLAUDE.md structure_\n  - _Requirements: All_\n  - _Prompt: Implement the task for spec enterprise-seo-optimization. First run spec-workflow-guide to get the workflow guide, then implement the task. Role: Technical Documentation Writer | Task: Update CLAUDE.md with new sections: 1) Add \"Content Management\" section documenting content/ directory structure, MDX format, frontmatter schemas, how to add new blog posts/portfolio projects/services/cities. 2) Add \"SEO Infrastructure\" section documenting Schema.org implementation, sitemap generation, RSS feed, meta tags, breadcrumbs. 3) Update \"Project Structure\" section to include new directories (lib/content/, lib/seo/, components/content/, components/seo/, content/). 4) Add quick start guide: \"Adding a New Blog Post\", \"Adding a Portfolio Project\", \"Testing SEO Locally\". Include code examples of frontmatter templates. Keep concise and developer-focused. Do NOT create new README.md (instructions say \"NEVER proactively create documentation files\"). Only update existing CLAUDE.md. | Restrictions: Only update existing CLAUDE.md, do not create new files, keep additions concise (max 200 lines added), provide frontmatter templates as examples, include validation commands (pnpm build checks), document Schema.org types used, explain sitemap auto-generation, use consistent formatting with existing CLAUDE.md, add to existing sections where logical (don't create redundant new sections), developer-focused not end-user docs | _Leverage: existing CLAUDE.md structure and tone, frontmatter examples from Tasks 28-31, design.md architecture documentation | _Requirements: All (documentation of complete system) | Success: CLAUDE.md updated with content management instructions, SEO infrastructure documented, frontmatter templates included, quick start guides added, consistent with existing style. Mark task as [ ] initially, then [-] when starting, then [x] when complete in tasks.md._\n",
  "fileStats": {
    "size": 69104,
    "lines": 339,
    "lastModified": "2025-10-01T17:58:33.926Z"
  },
  "comments": []
}
